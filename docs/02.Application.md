# Application Deployment Guide

This document covers the Node.js application, containerization, Kubernetes deployment using Helm, and Gateway API configuration.

## Table of Contents

- [Application Overview](#application-overview)
- [Containerization](#containerization)
- [Kubernetes Deployment](#kubernetes-deployment)
- [Helm Chart](#helm-chart)
- [Gateway API](#gateway-api)
- [Secrets Management](#secrets-management)
- [Health Checks](#health-checks)
- [Scaling and Resources](#scaling-and-resources)
- [Deployment Guide](#deployment-guide)
- [Troubleshooting](#troubleshooting)

## Application Overview

### Technology Stack

| Component | Technology | Version | Purpose |
|-----------|-----------|---------|---------|
| Runtime | Node.js | 18 | JavaScript execution |
| Framework | Express | 4.18.2 | Web framework |
| Container | Docker | Alpine-based | Containerization |
| Orchestration | Kubernetes (EKS) | 1.28+ | Container orchestration |
| Package Manager | Helm | 3.13+ | Kubernetes deployment |

### Application Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Internet/Users                        │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    Gateway API                           │
│  ┌──────────────┐   ┌──────────────┐                    │
│  │ GatewayClass │   │   Gateway    │   ┌─────────────┐  │
│  └──────────────┘   └──────────────┘   │ HTTPRoute   │  │
│                                         └─────────────┘  │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Kubernetes Service (ClusterIP)              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                   Deployment                             │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐            │
│  │   Pod 1  │   │   Pod 2  │   │   Pod N  │            │
│  │          │   │          │   │          │            │
│  │ Node.js  │   │ Node.js  │   │ Node.js  │            │
│  │ Express  │   │ Express  │   │ Express  │            │
│  │          │   │          │   │          │            │
│  │ Port 3000│   │ Port 3000│   │ Port 3000│            │
│  └──────────┘   └──────────┘   └──────────┘            │
└─────────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              AWS Secrets Manager                         │
│              (API Keys & Credentials)                    │
└─────────────────────────────────────────────────────────┘
```

### Source Code

**Location**: `src/`

#### Application Code (`index.js`)

```javascript
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/health', (req, res) => res.send('OK'));

app.get('/', (req, res) => {
  res.json({ message: "Hello from Node.js app running on Kubernetes!" });
});

app.listen(port, () => {
  console.log(`App listening on port ${port}`);
});
```

#### Dependencies (`package.json`)

```json
{
  "name": "nodejs-simple-app",
  "version": "1.0.0",
  "description": "Simple Node.js app for Kubernetes deployment",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
```

### API Endpoints

| Endpoint | Method | Description | Response |
|----------|--------|-------------|----------|
| `/` | GET | Main endpoint | `{"message": "Hello from Node.js..."}` |
| `/health` | GET | Health check | `OK` |

## Containerization

### Dockerfile

**Location**: `src/Dockerfile`

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD ["node", "index.js"]
```

### Multi-Stage Build Benefits

The current Dockerfile is simple but production-ready:

✅ **Lightweight Base**: `node:18-alpine` (~120MB vs ~900MB for full Node image)
✅ **Layer Caching**: Dependencies installed before source code copy
✅ **Minimal Attack Surface**: Alpine has fewer packages
✅ **Clear Entrypoint**: Single responsibility

### Building Locally

```bash
cd src

# Build image
docker build -t nodejs-simple-app:local .

# Run locally
docker run -d -p 3000:3000 \
  -e PORT=3000 \
  nodejs-simple-app:local

# Test
curl http://localhost:3000/
curl http://localhost:3000/health

# View logs
docker logs <container-id>

# Stop container
docker stop <container-id>
```

### Image Registry

Images are stored in **GitHub Container Registry (GHCR)**:

```
ghcr.io/<username>/ops-solution:latest
ghcr.io/<username>/ops-solution:main-abc1234
ghcr.io/<username>/ops-solution:v1.0.0
```

## Kubernetes Deployment

### Resource Structure

```
kube/
├── helm/                    # Helm chart (primary deployment method)
│   ├── Chart.yaml
│   ├── values.yaml
│   └── templates/
│       ├── deployment.yaml
│       ├── service.yaml
│       ├── secret.yaml
│       └── _helpers.tpl
└── k8s/                     # Gateway API resources (standalone)
    ├── gatewayclass.yaml
    ├── gateway.yaml
    └── httproute.yaml
```

### Deployment Manifests

#### Deployment (`templates/deployment.yaml`)

Key features:
- **Replicas**: 2 pods for high availability
- **Health Checks**: Startup, liveness, readiness probes
- **Resource Limits**: CPU and memory constraints
- **Security Context**: Non-root user, dropped capabilities
- **Environment Variables**: Port configuration
- **Secrets**: Mounted from AWS Secrets Manager

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nodejs-simple-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nodejs-simple-app
  template:
    metadata:
      labels:
        app: nodejs-simple-app
    spec:
      securityContext:
        fsGroup: 1001
      containers:
      - name: nodejs-simple-app
        image: ghcr.io/username/ops-solution:latest
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: api-key-secret
              key: API_KEY
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        startupProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 6
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
```

#### Service (`templates/service.yaml`)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nodejs-simple-app
spec:
  type: ClusterIP
  ports:
  - port: 3000
    targetPort: 3000
    protocol: TCP
    name: http
  selector:
    app: nodejs-simple-app
```

**Service Type**: `ClusterIP`
- Internal access only
- Exposed via Gateway API
- More secure than LoadBalancer

## Helm Chart

### Chart Structure

**Location**: `kube/helm/`

```
helm/
├── Chart.yaml          # Chart metadata
├── values.yaml         # Default values
└── templates/
    ├── _helpers.tpl    # Template helpers
    ├── deployment.yaml # Deployment manifest
    ├── service.yaml    # Service manifest
    └── secret.yaml     # Secret manifest
```

### Chart Metadata (`Chart.yaml`)

```yaml
apiVersion: v2
name: nodejs-simple-app
description: A Helm chart for Node.js simple application on Kubernetes
type: application
version: 1.0.0
appVersion: "1.0.0"
```

### Values File (`values.yaml`)

```yaml
replicaCount: 2

image:
  repository: ghcr.io/username/ops-solution
  pullPolicy: IfNotPresent
  tag: "latest"

service:
  type: ClusterIP
  port: 3000
  targetPort: 3000

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

env:
  - name: PORT
    value: "3000"

startupProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 6

livenessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

secret:
  apiKey:
    enabled: true
    create: true
    value: ""  # Set via --set-string during deployment
    mountPath: "/etc/secrets"

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1001
  allowPrivilegeEscalation: false
```

### Customizing Values

#### Development Override

```yaml
# values-dev.yaml
replicaCount: 1

resources:
  limits:
    cpu: 250m
    memory: 256Mi
  requests:
    cpu: 50m
    memory: 64Mi
```

#### Production Override

```yaml
# values-prod.yaml
replicaCount: 3

image:
  tag: "v1.2.3"

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 200m
    memory: 256Mi

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - nodejs-simple-app
        topologyKey: kubernetes.io/hostname
```

## Gateway API

### Why Gateway API over Ingress?

| Feature | Ingress | Gateway API |
|---------|---------|-------------|
| **Design** | Monolithic | Role-oriented |
| **Flexibility** | Limited | Highly extensible |
| **Traffic Management** | Basic | Advanced (header, query params) |
| **Multiple Protocols** | HTTP/HTTPS only | HTTP, HTTPS, TCP, UDP, gRPC |
| **Cross-Namespace** | Limited | Native support |
| **Standards** | Vendor-specific | Standardized API |
| **Future** | Maintenance mode | Active development |

### Gateway API Resources

#### 1. GatewayClass

**Location**: `kube/k8s/gatewayclass.yaml`

Defines which controller manages the Gateway.

```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: GatewayClass
metadata:
  name: nodejs-app-gateway-class
spec:
  controllerName: gateway.networking.k8s.io/gateway-controller
  description: "Gateway class for nodejs-simple-app"
```

**Controller Options**:
- AWS Load Balancer Controller
- Istio Gateway
- Nginx Gateway
- Envoy Gateway

#### 2. Gateway

**Location**: `kube/k8s/gateway.yaml`

Configures the load balancer with listeners.

```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: nodejs-app-gateway
  namespace: default
spec:
  gatewayClassName: nodejs-app-gateway-class
  listeners:
    - name: https
      protocol: HTTPS
      port: 443
      hostname: "api.mohibulalam.xyz"
      tls:
        mode: Terminate
        certificateRefs:
          - kind: Secret
            name: api-mohibulalam-xyz-tls
            namespace: default
      allowedRoutes:
        namespaces:
          from: Same
    - name: http
      protocol: HTTP
      port: 80
      hostname: "api.mohibulalam.xyz"
      allowedRoutes:
        namespaces:
          from: Same
```

**Features**:
- ✅ HTTPS termination with TLS certificate
- ✅ HTTP listener for redirect (optional)
- ✅ Hostname-based routing
- ✅ Namespace isolation

#### 3. HTTPRoute

**Location**: `kube/k8s/httproute.yaml`

Defines routing rules to backend services.

```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: nodejs-app-httproute
  namespace: default
spec:
  parentRefs:
    - name: nodejs-app-gateway
      namespace: default
      sectionName: https
  hostnames:
    - "api.mohibulalam.xyz"
  rules:
    - matches:
        - path:
            type: PathPrefix
            value: /
      backendRefs:
        - name: nodejs-simple-app
          port: 3000
          weight: 100
```

**Advanced Routing Examples**:

```yaml
# Path-based routing
rules:
  - matches:
      - path:
          type: PathPrefix
          value: /api
    backendRefs:
      - name: api-service
        port: 8080

  - matches:
      - path:
          type: PathPrefix
          value: /admin
    backendRefs:
      - name: admin-service
        port: 9090

# Header-based routing
rules:
  - matches:
      - headers:
          - name: x-version
            value: v2
    backendRefs:
      - name: app-v2
        port: 3000

# Query parameter routing
rules:
  - matches:
      - queryParams:
          - name: beta
            value: "true"
    backendRefs:
      - name: beta-app
        port: 3000
```

### Installing Gateway API CRDs

```bash
# Install standard version
kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml

# Verify installation
kubectl get crd | grep gateway

# Expected output:
# gatewayclasses.gateway.networking.k8s.io
# gateways.gateway.networking.k8s.io
# httproutes.gateway.networking.k8s.io
```

## Secrets Management

### AWS Secrets Manager Integration

Secrets are stored in AWS Secrets Manager and fetched during CI/CD deployment.

#### Creating Secrets in AWS

```bash
# Create secret
aws secretsmanager create-secret \
  --name ops-solution-api-keys \
  --description "API keys for ops-solution app" \
  --secret-string '{"API_KEY":"your-secret-key-here"}' \
  --region ap-southeast-1

# Update secret
aws secretsmanager update-secret \
  --secret-id ops-solution-api-keys \
  --secret-string '{"API_KEY":"new-secret-key"}' \
  --region ap-southeast-1

# Retrieve secret
aws secretsmanager get-secret-value \
  --secret-id ops-solution-api-keys \
  --region ap-southeast-1
```

#### Kubernetes Secret Creation

Secrets are created during Helm deployment:

```bash
# In CI/CD pipeline
API_KEY=$(aws secretsmanager get-secret-value \
  --secret-id ops-solution-api-keys \
  --region ap-southeast-1 \
  --query SecretString \
  --output text | jq -r '.API_KEY')

helm upgrade --install nodejs-simple-app ./helm \
  --set-string secret.apiKey.value="$API_KEY"
```

#### Secret Mounting

Secrets are mounted as files in the container:

```yaml
volumeMounts:
  - name: api-key-secret
    mountPath: /etc/secrets
    readOnly: true

volumes:
  - name: api-key-secret
    secret:
      secretName: api-key-secret
      items:
        - key: API_KEY
          path: api-key
      defaultMode: 0400  # Read-only for owner
```

**Access in Application**:
```javascript
const fs = require('fs');
const apiKey = fs.readFileSync('/etc/secrets/api-key', 'utf8');
```

Or via environment variable:
```javascript
const apiKey = process.env.API_KEY;
```

## Health Checks

### Types of Probes

#### 1. Startup Probe

**Purpose**: Protects slow-starting containers

```yaml
startupProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 6  # 30 seconds total (5s * 6)
```

- Runs first, before liveness/readiness
- Allows up to 30 seconds for app to start
- Other probes disabled until startup succeeds

#### 2. Liveness Probe

**Purpose**: Restarts unhealthy containers

```yaml
livenessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3  # Restart after 30s (10s * 3)
```

- Checks if application is alive
- Restarts container if fails
- Should detect hung processes, deadlocks

#### 3. Readiness Probe

**Purpose**: Controls traffic routing

```yaml
readinessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3  # Remove from service after 15s (5s * 3)
```

- Checks if app can handle requests
- Removes pod from service if fails
- Doesn't restart container

### Health Check Flow

```
Container Start
      ↓
  Startup Probe (checks every 5s, max 6 failures = 30s)
      ↓
   Success!
      ↓
  ┌─────────────────────┐
  │  Liveness Probe     │ ← Checks every 10s
  │  (Restart if fail)  │    Restarts after 3 failures
  └─────────────────────┘
      ↓
  ┌─────────────────────┐
  │  Readiness Probe    │ ← Checks every 5s
  │  (Route traffic)    │    Removes from service after 3 failures
  └─────────────────────┘
```

## Scaling and Resources

### Resource Management

#### CPU and Memory

```yaml
resources:
  requests:
    cpu: 100m      # 0.1 CPU core (minimum guaranteed)
    memory: 128Mi  # 128 MiB (minimum guaranteed)
  limits:
    cpu: 500m      # 0.5 CPU core (maximum allowed)
    memory: 512Mi  # 512 MiB (maximum allowed)
```

**Request vs Limit**:
- **Request**: Minimum guaranteed resources
- **Limit**: Maximum allowed resources
- **Throttling**: CPU is throttled, memory causes OOMKill

#### Quality of Service Classes

| Class | Condition | Eviction Priority |
|-------|-----------|------------------|
| **Guaranteed** | requests = limits | Lowest (last to evict) |
| **Burstable** | requests < limits | Medium |
| **BestEffort** | No requests/limits | Highest (first to evict) |

### Horizontal Pod Autoscaler (HPA)

**Not included by default, but can be added**:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nodejs-simple-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nodejs-simple-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
```

**Enable in Helm**:
```yaml
# values.yaml
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
```

### Vertical Pod Autoscaler (VPA)

**For right-sizing resources**:

```bash
# Install VPA
kubectl apply -f https://github.com/kubernetes/autoscaler/releases/download/vertical-pod-autoscaler-0.13.0/vpa-v0.13.0.yaml

# Create VPA
kubectl apply -f - <<EOF
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: nodejs-simple-app-vpa
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nodejs-simple-app
  updatePolicy:
    updateMode: "Auto"
EOF

# Get recommendations
kubectl describe vpa nodejs-simple-app-vpa
```

## Deployment Guide

### Prerequisites

- EKS cluster running
- kubectl configured
- Helm 3.13+ installed
- Gateway API CRDs installed
- Secrets in AWS Secrets Manager

### Step-by-Step Deployment

#### 1. Verify Cluster Access

```bash
# Check cluster connection
kubectl cluster-info

# Check nodes
kubectl get nodes

# Check namespaces
kubectl get namespaces
```

#### 2. Install Gateway API CRDs (if not already)

```bash
kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml

# Verify
kubectl get crd | grep gateway
```

#### 3. Create TLS Certificate (for HTTPS)

```bash
# Option 1: Using cert-manager (recommended)
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: api-mohibulalam-xyz-tls
  namespace: default
spec:
  secretName: api-mohibulalam-xyz-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - api.mohibulalam.xyz
EOF

# Option 2: Manual certificate
kubectl create secret tls api-mohibulalam-xyz-tls \
  --cert=path/to/tls.crt \
  --key=path/to/tls.key \
  --namespace=default
```

#### 4. Fetch Secrets from AWS

```bash
# Fetch API key
API_KEY=$(aws secretsmanager get-secret-value \
  --secret-id ops-solution-api-keys \
  --region ap-southeast-1 \
  --query SecretString \
  --output text | jq -r '.API_KEY')

# Verify (without printing)
if [ -z "$API_KEY" ]; then
  echo "ERROR: Failed to fetch API_KEY"
  exit 1
fi
```

#### 5. Deploy with Helm

```bash
cd kube/helm

# Development deployment
helm upgrade --install nodejs-simple-app . \
  --namespace default \
  --create-namespace \
  --set image.repository=ghcr.io/username/ops-solution \
  --set image.tag=latest \
  --set-string secret.apiKey.value="$API_KEY" \
  --wait \
  --timeout 5m

# Production deployment (with more options)
helm upgrade --install nodejs-simple-app . \
  --namespace production \
  --create-namespace \
  --values values-prod.yaml \
  --set image.repository=ghcr.io/username/ops-solution \
  --set image.tag=v1.2.3 \
  --set-string secret.apiKey.value="$API_KEY" \
  --atomic \
  --cleanup-on-fail \
  --wait \
  --timeout 8m
```

**Helm Options Explained**:
- `--atomic`: Rollback on failure
- `--cleanup-on-fail`: Delete resources on failure
- `--wait`: Wait for resources to be ready
- `--timeout`: Max wait time

#### 6. Deploy Gateway API Resources

```bash
cd kube/k8s

# Apply Gateway API resources
kubectl apply -f gatewayclass.yaml
kubectl apply -f gateway.yaml
kubectl apply -f httproute.yaml

# Verify
kubectl get gatewayclass
kubectl get gateway
kubectl get httproute
```

#### 7. Verify Deployment

```bash
# Check deployment
kubectl get deployment nodejs-simple-app

# Check pods
kubectl get pods -l app.kubernetes.io/name=nodejs-simple-app

# Check service
kubectl get svc nodejs-simple-app

# Check gateway
kubectl get gateway nodejs-app-gateway

# Check route
kubectl get httproute nodejs-app-httproute
```

#### 8. Test Application

```bash
# Port-forward for local testing
kubectl port-forward svc/nodejs-simple-app 8080:3000

# Test endpoints
curl http://localhost:8080/
curl http://localhost:8080/health

# Test via Gateway (if DNS configured)
curl https://api.mohibulalam.xyz/
curl https://api.mohibulalam.xyz/health
```

### Rolling Updates

```bash
# Update image version
helm upgrade nodejs-simple-app ./helm \
  --set image.tag=v1.2.4 \
  --reuse-values \
  --wait

# Check rollout status
kubectl rollout status deployment/nodejs-simple-app

# View rollout history
kubectl rollout history deployment/nodejs-simple-app

# Rollback if needed
kubectl rollback deployment/nodejs-simple-app
# Or with Helm
helm rollback nodejs-simple-app
```

### Blue-Green Deployment

```yaml
# Create green deployment
helm install nodejs-simple-app-green ./helm \
  --set image.tag=v2.0.0 \
  --set-string secret.apiKey.value="$API_KEY"

# Test green deployment
kubectl port-forward svc/nodejs-simple-app-green 8080:3000

# Update HTTPRoute to route traffic to green
kubectl patch httproute nodejs-app-httproute --type=json -p='[
  {
    "op": "replace",
    "path": "/spec/rules/0/backendRefs",
    "value": [
      {"name": "nodejs-simple-app-green", "port": 3000, "weight": 100}
    ]
  }
]'

# Remove old blue deployment
helm uninstall nodejs-simple-app
```

### Canary Deployment

```yaml
# Deploy canary version
helm install nodejs-simple-app-canary ./helm \
  --set image.tag=v2.0.0-canary \
  --set replicaCount=1

# Split traffic (90% stable, 10% canary)
kubectl patch httproute nodejs-app-httproute --type=json -p='[
  {
    "op": "replace",
    "path": "/spec/rules/0/backendRefs",
    "value": [
      {"name": "nodejs-simple-app", "port": 3000, "weight": 90},
      {"name": "nodejs-simple-app-canary", "port": 3000, "weight": 10}
    ]
  }
]'

# Monitor metrics, then gradually increase canary weight
# 50-50
# 0-100 (full canary)
```

## Troubleshooting

### Common Issues

#### 1. Pods Not Starting

```bash
# Check pod status
kubectl get pods

# Describe pod for events
kubectl describe pod <pod-name>

# Check logs
kubectl logs <pod-name>
kubectl logs <pod-name> --previous  # Previous container instance
```

**Common Causes**:
- Image pull errors
- Resource limits too low
- Failed health checks
- Missing secrets

#### 2. Image Pull Errors

**Error**: `ImagePullBackOff` or `ErrImagePull`

```bash
# Check image pull secret
kubectl get secrets
kubectl describe secret <image-pull-secret>

# Create image pull secret (if missing)
kubectl create secret docker-registry ghcr-secret \
  --docker-server=ghcr.io \
  --docker-username=<github-username> \
  --docker-password=<github-token> \
  --docker-email=<email>

# Add to deployment
kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "ghcr-secret"}]}'
```

#### 3. Health Check Failures

**Error**: Pods constantly restarting

```bash
# Check probe configuration
kubectl describe pod <pod-name> | grep -A 5 Probe

# Check application logs
kubectl logs <pod-name>

# Exec into container
kubectl exec -it <pod-name> -- sh
wget -O- http://localhost:3000/health
```

**Solutions**:
- Increase `initialDelaySeconds`
- Increase `failureThreshold`
- Fix health endpoint
- Check application startup time

#### 4. Gateway Not Working

```bash
# Check Gateway status
kubectl describe gateway nodejs-app-gateway

# Check HTTPRoute status
kubectl describe httproute nodejs-app-httproute

# Check Gateway controller logs
kubectl logs -n kube-system -l app=gateway-controller
```

**Common Issues**:
- Gateway controller not installed
- TLS certificate not found
- Hostname not resolving
- Service selector mismatch

#### 5. Service Not Reachable

```bash
# Check service
kubectl get svc nodejs-simple-app

# Check endpoints
kubectl get endpoints nodejs-simple-app

# Test from another pod
kubectl run test --rm -it --image=busybox -- sh
wget -O- http://nodejs-simple-app:3000/health
```

#### 6. Secret Not Mounted

```bash
# Check if secret exists
kubectl get secret api-key-secret

# Check secret content (base64 encoded)
kubectl get secret api-key-secret -o yaml

# Check volume mount in pod
kubectl describe pod <pod-name> | grep -A 10 Mounts

# Exec and check file
kubectl exec -it <pod-name> -- cat /etc/secrets/api-key
```

### Debug Commands

```bash
# Get all resources
kubectl get all

# Describe resources
kubectl describe deployment nodejs-simple-app
kubectl describe pod <pod-name>
kubectl describe svc nodejs-simple-app

# View logs
kubectl logs -f <pod-name>
kubectl logs <pod-name> --tail=100
kubectl logs -l app=nodejs-simple-app --all-containers=true

# Exec into container
kubectl exec -it <pod-name> -- sh

# Port forward
kubectl port-forward pod/<pod-name> 8080:3000
kubectl port-forward svc/nodejs-simple-app 8080:3000

# Events
kubectl get events --sort-by='.lastTimestamp'

# Resource usage
kubectl top nodes
kubectl top pods
```

## Next Steps

After successful deployment:

1. ✅ Set up monitoring (see monitoring documentation)
2. ✅ Configure log aggregation
3. ✅ Implement alerting
4. ✅ Set up backup strategies
5. ✅ Document runbooks
6. ✅ Load testing

---

**Related Documentation**:
- [Infrastructure Guide](01.IAC.md)
- [CI/CD Workflow Guide](03.Workflow.md)
- [OPA Policy Guide](04.OPA.md)
- [Main README](../README.md)

*Last updated: December 10, 2025*

