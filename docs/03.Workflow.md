# CI/CD Workflow Guide

This document provides a comprehensive guide to the GitHub Actions CI/CD pipelines for both application and infrastructure deployment.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Application Pipeline](#application-pipeline)
- [Infrastructure Pipeline](#infrastructure-pipeline)
- [GitHub OIDC Setup](#github-oidc-setup)
- [Secrets Configuration](#secrets-configuration)
- [Workflow Triggers](#workflow-triggers)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Overview

The project uses **GitHub Actions** for continuous integration and deployment with two separate workflows:

1. **Application CI/CD** (`ci-cd.yml`) - Builds, tests, and deploys the Node.js application
2. **Infrastructure CI/CD** (`terraform.yml`) - Validates and deploys Terraform infrastructure

### Key Features

✅ **Automated Testing**: Every code change is tested automatically  
✅ **OPA Policy Validation**: Infrastructure changes validated against policies  
✅ **Multi-Environment**: Separate dev and prod environments  
✅ **Atomic Deployments**: Automatic rollback on failure  
✅ **Security**: OIDC authentication, no long-lived credentials  
✅ **Caching**: Build and registry caching for speed  
✅ **Cost Optimization**: Efficient resource usage

## Architecture

### Pipeline Overview

```
┌─────────────────────────────────────────────────────────────┐
│                       Developer                              │
│                           ↓                                  │
│                    Git Push/PR                               │
└────────────────────┬────────────────────────────────────────┘
                     │
         ┌───────────┴──────────┐
         │                      │
    ┌────▼────┐           ┌────▼────┐
    │ Changed │           │ Changed │
    │   src/  │           │   iac/  │
    │  kube/  │           │         │
    └────┬────┘           └────┬────┘
         │                     │
    ┌────▼─────────┐    ┌─────▼────────┐
    │ Application  │    │ Infrastructure│
    │   Pipeline   │    │   Pipeline    │
    │              │    │               │
    │ 1. Build     │    │ 1. Format     │
    │ 2. Test      │    │ 2. Validate   │
    │ 3. Deploy    │    │ 3. Plan       │
    │              │    │ 4. OPA Check  │
    │              │    │ 5. Apply      │
    └────┬─────────┘    └─────┬────────┘
         │                     │
         ▼                     ▼
┌─────────────────────────────────────┐
│          AWS EKS Cluster             │
│  ┌──────────┐      ┌──────────┐     │
│  │   App    │      │   VPC    │     │
│  │  Pods    │      │   EKS    │     │
│  └──────────┘      └──────────┘     │
└─────────────────────────────────────┘
```

### Workflow Files

**Location**: `.github/workflows/`

| File | Purpose | Triggers |
|------|---------|----------|
| `ci-cd.yml` | Application deployment | Push to main/develop, PRs on src/kube |
| `terraform.yml` | Infrastructure deployment | Push to main, PRs on iac/ |

## Application Pipeline

**File**: `.github/workflows/ci-cd.yml`

### Pipeline Stages

```
┌──────────────────────────────────────────────────────────┐
│                    Build and Test Job                     │
│                                                           │
│  1. Checkout Code                                         │
│  2. Setup Docker Buildx                                   │
│  3. Login to GHCR                                         │
│  4. Extract Metadata (tags, labels)                       │
│  5. Build & Push Image (with caching)                     │
│     ├─ Registry Cache                                     │
│     └─ GitHub Actions Cache                               │
│  6. Output: image-tag, image-digest                       │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│                        Test Job                           │
│                                                           │
│  1. Login to GHCR                                         │
│  2. Pull Built Image                                      │
│  3. Run Container                                         │
│  4. Health Check Test (15 attempts, 2s interval)          │
│  5. API Endpoint Test                                     │
│  6. Cleanup                                               │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│                       Deploy Job                          │
│                  (main branch only)                       │
│                                                           │
│  1. Checkout Code (kube/helm)                             │
│  2. Configure AWS Credentials (OIDC)                      │
│  3. Fetch Secrets from AWS Secrets Manager                │
│  4. Setup kubectl                                         │
│  5. Setup Helm                                            │
│  6. Configure kubectl for EKS                             │
│  7. Helm Upgrade (atomic)                                 │
│  8. Verify Deployment                                     │
│  9. Rollback on Failure                                   │
└──────────────────────────────────────────────────────────┘
```

### Build Stage

#### Docker Build with Multi-Layer Caching

```yaml
- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    context: ./src
    file: ./src/Dockerfile
    push: true
    tags: ${{ steps.meta.outputs.tags }}
    labels: ${{ steps.meta.outputs.labels }}
    cache-from: |
      type=registry,ref=ghcr.io/username/ops-solution:buildcache
      type=gha
    cache-to: |
      type=registry,ref=ghcr.io/username/ops-solution:buildcache,mode=max
      type=gha,mode=max
    platforms: linux/amd64
```

**Cache Strategy**:
1. **Registry Cache**: Persists across workflows and runners
2. **GitHub Actions Cache**: Fast local cache

**Benefits**:
- ✅ Faster builds (reuse layers)
- ✅ Cross-runner caching
- ✅ Reduced bandwidth
- ✅ Lower costs

#### Image Tagging Strategy

```yaml
tags: |
  type=ref,event=branch           # main, develop
  type=ref,event=pr               # pr-123
  type=sha,prefix={{branch}}-     # main-abc1234
  type=raw,value=latest,enable={{is_default_branch}}  # latest
```

**Examples**:
- `main` → `ghcr.io/username/ops-solution:main`
- `main` → `ghcr.io/username/ops-solution:main-abc1234`
- `main` → `ghcr.io/username/ops-solution:latest`
- `PR #42` → `ghcr.io/username/ops-solution:pr-42`

### Test Stage

#### Health Check with Retry Logic

```bash
max_attempts=15
attempt=0

while [ $attempt -lt $max_attempts ]; do
  if curl -f http://localhost:3000/health; then
    echo "✓ Health check passed!"
    break
  fi
  
  attempt=$((attempt + 1))
  echo "Attempt $attempt/$max_attempts failed, retrying..."
  sleep 2
done

if [ $attempt -eq $max_attempts ]; then
  echo "✗ Health check failed after $max_attempts attempts"
  docker logs test-container
  exit 1
fi
```

**Configuration**:
- Max attempts: 15
- Interval: 2 seconds
- Total timeout: 30 seconds

#### API Endpoint Validation

```bash
response=$(curl -s http://localhost:3000/)
echo "Response: $response"

if echo "$response" | grep -q "Hello from Node.js app"; then
  echo "✓ API test passed!"
else
  echo "✗ API test failed!"
  docker logs test-container
  exit 1
fi
```

### Deploy Stage

#### AWS Authentication (OIDC)

```yaml
- name: Configure AWS Credentials
  uses: aws-actions/configure-aws-credentials@v4
  with:
    role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
    aws-region: ${{ secrets.AWS_REGION }}
```

**Benefits over Access Keys**:
- ✅ No long-lived credentials
- ✅ Automatic token rotation
- ✅ Better audit trail
- ✅ Follows AWS best practices

#### Secrets Fetching

```bash
# Fetch secret from AWS Secrets Manager
SECRET_VALUE=$(aws secretsmanager get-secret-value \
  --secret-id "$SECRET_NAME" \
  --region "$AWS_REGION" \
  --query SecretString \
  --output text)

# Extract API_KEY from JSON
API_KEY=$(echo "$SECRET_VALUE" | jq -r '.API_KEY')

# Verify API_KEY was retrieved
if [ -z "$API_KEY" ] || [ "$API_KEY" = "null" ]; then
  echo "ERROR: Failed to retrieve API_KEY from Secrets Manager"
  exit 1
fi

# Mask secret in logs
echo "::add-mask::$API_KEY"

# Export for next steps
echo "API_KEY=$API_KEY" >> $GITHUB_ENV
```

#### Atomic Helm Deployment

```yaml
- name: Deploy with Helm (atomic operation)
  timeout-minutes: 10
  run: |
    helm upgrade --install nodejs-simple-app . \
      --namespace default \
      --create-namespace \
      --atomic \
      --cleanup-on-fail \
      --wait \
      --timeout 8m \
      --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
      --set image.tag=${{ github.sha }} \
      --set-string secret.apiKey.value="$API_KEY"
```

**Atomic Deployment Flags**:
- `--atomic`: Rollback on failure
- `--cleanup-on-fail`: Delete failed resources
- `--wait`: Wait for resources to be ready
- `--timeout 8m`: Maximum wait time

**What Happens on Failure**:
1. Deployment fails (e.g., health checks fail)
2. Helm automatically rolls back to previous version
3. Failed resources are cleaned up
4. Pipeline fails with error message

#### Deployment Verification

```bash
# Wait for rollout to complete
kubectl rollout status deployment/nodejs-simple-app -n default --timeout=3m

# Wait for pods to be ready
kubectl wait --for=condition=ready pod \
  -l app.kubernetes.io/name=nodejs-simple-app \
  -n default \
  --timeout=3m

echo "✓ Deployment successful!"
```

### Complete Workflow Example

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'kube/**'
      - '.github/workflows/**'
  pull_request:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'kube/**'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      # Build steps...
      
  test:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      # Test steps...
      
  deploy:
    needs: [build-and-test, test]
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read
      packages: read
    environment:
      name: production
    
    steps:
      # Deploy steps...
```

## Infrastructure Pipeline

**File**: `.github/workflows/terraform.yml`

### Pipeline Stages

```
┌──────────────────────────────────────────────────────────┐
│              Terraform Plan & OPA Validation              │
│                  (Runs for dev AND prod)                  │
│                                                           │
│  1. Checkout Code                                         │
│  2. Configure AWS Credentials (OIDC)                      │
│  3. Setup Terraform                                       │
│  4. Setup OPA                                             │
│  5. Terraform Format Check                                │
│  6. Terraform Init (with backend)                         │
│  7. Terraform Validate                                    │
│  8. Terraform Plan (output binary)                        │
│  9. Generate JSON Plan                                    │
│ 10. Run OPA Policy Validation                             │
│     ├─ terraform.rego (best practices)                    │
│     ├─ security.rego (security policies)                  │
│     └─ cost_control.rego (cost policies)                  │
│ 11. Upload Plan Artifacts                                 │
│ 12. Fail if any step failed                               │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│                   Terraform Apply                         │
│             (main branch, dev env only)                   │
│                                                           │
│  1. Checkout Code                                         │
│  2. Configure AWS Credentials (OIDC)                      │
│  3. Setup Terraform                                       │
│  4. Terraform Init                                        │
│  5. Download Plan Artifact                                │
│  6. Terraform Apply (plan file)                           │
│  7. Notify Success/Failure                                │
└──────────────────────────────────────────────────────────┘
```

### Plan Stage

#### Matrix Strategy for Multi-Environment

```yaml
strategy:
  matrix:
    environment: [dev, prod]
```

**Runs in parallel**:
- Dev plan
- Prod plan

Both must pass for pipeline to succeed.

#### Terraform Format Check

```bash
terraform fmt -check -recursive
```

**Purpose**: Ensure code follows Terraform formatting standards

**Failure Example**:
```
main.tf
--- old/main.tf
+++ new/main.tf
@@ -1,3 +1,3 @@
-resource "aws_vpc" "main"{
+resource "aws_vpc" "main" {
   cidr_block = "10.0.0.0/16"
 }
```

#### Terraform Init with Backend

```bash
terraform init \
  -backend-config=backend-${{ matrix.environment }}.hcl \
  -upgrade
```

**Backend Configuration**:
- Dev: `backend-dev.hcl` → `dev/terraform.tfstate`
- Prod: `backend-prod.hcl` → `prod/terraform.tfstate`

#### Terraform Plan

```bash
terraform plan \
  -var-file=${{ matrix.environment }}.tfvars \
  -out=tfplan.binary \
  -no-color
```

**Outputs**:
- Binary plan file: `tfplan.binary`
- JSON plan: `tfplan.json` (for OPA)

#### OPA Policy Validation

```bash
chmod +x scripts/validate-with-opa.sh
scripts/validate-with-opa.sh tfplan.json
```

**Validation Script** (`scripts/validate-with-opa.sh`):

```bash
#!/bin/bash

PLAN_FILE=$1

echo "Running OPA Policy Validation..."
echo "================================="

# Check Terraform best practices
echo "Checking Terraform policies..."
opa eval --data iac/policies/terraform.rego \
         --input "$PLAN_FILE" \
         --format pretty \
         "data.terraform.deny"

if [ $? -ne 0 ]; then
  echo "✗ Terraform policy violations found"
  exit 1
fi
echo "✓ Terraform policies: PASSED"

# Check security policies
echo "Checking security policies..."
opa eval --data iac/policies/security.rego \
         --input "$PLAN_FILE" \
         --format pretty \
         "data.security.deny"

if [ $? -ne 0 ]; then
  echo "✗ Security policy violations found"
  exit 1
fi
echo "✓ Security policies: PASSED"

# Check cost control policies
echo "Checking cost control policies..."
opa eval --data iac/policies/cost_control.rego \
         --input "$PLAN_FILE" \
         --format pretty \
         "data.cost_control.deny"

if [ $? -ne 0 ]; then
  echo "✗ Cost control policy violations found"
  exit 1
fi
echo "✓ Cost control policies: PASSED"

echo ""
echo "================================="
echo "✓ All OPA validations passed!"
```

**Policies Checked**:
1. **Terraform Best Practices**: Tagging, naming, configuration
2. **Security**: Encryption, IMDSv2, security groups
3. **Cost Control**: Instance types, disk sizes, node counts

**Example Violation**:
```
FAIL: EKS cluster 'ops-solution-dev-eks' must have private endpoint access enabled
FAIL: VPC 'ops-solution-dev-vpc' missing required tag: ManagedBy
FAIL: Dev environment cannot use instance type 't3.large' (max: t3.medium)
```

#### Artifact Upload

```yaml
- name: Upload Plan Artifact
  uses: actions/upload-artifact@v4
  with:
    name: tfplan-${{ matrix.environment }}
    path: iac/tfplan.binary
    retention-days: 5
```

**Purpose**: Store plan for apply stage

### Apply Stage

#### Conditional Execution

```yaml
terraform-apply:
  needs: terraform-plan
  if: github.ref == 'refs/heads/main' && github.event_name == 'push'
  strategy:
    matrix:
      environment: [dev]  # Only dev auto-deploys
```

**Apply Triggers**:
- ✅ Push to `main` → Auto-apply to `dev`
- ✅ Manual dispatch → Apply to selected environment
- ❌ Pull requests → Plan only (no apply)
- ❌ Production → Manual approval required

#### GitHub Environments

```yaml
environment:
  name: ${{ matrix.environment }}
```

**Environment Protection Rules** (configured in GitHub):
- **Dev**: No approvals, auto-deploy
- **Prod**: Require approvals, manual trigger

#### Download and Apply

```bash
# Download plan from previous stage
# (automatically handled by actions/download-artifact)

# Apply the plan
terraform apply -auto-approve tfplan.binary
```

**Why use plan file**:
- ✅ Ensures exactly what was reviewed is applied
- ✅ Prevents "drift" between plan and apply
- ✅ Faster apply (no re-planning)

### Complete Workflow Example

```yaml
name: Terraform CI/CD with OPA

on:
  pull_request:
    branches: [main, develop]
    paths: ['iac/**']
  push:
    branches: [main]
    paths: ['iac/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options: [dev, prod]

env:
  TF_VERSION: '1.6.0'
  OPA_VERSION: '0.59.0'
  AWS_REGION: 'ap-southeast-1'

jobs:
  terraform-plan:
    name: Terraform Plan & OPA Validation
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [dev, prod]
    permissions:
      contents: read
      pull-requests: write
      id-token: write
    
    steps:
      # Plan steps...
      
  terraform-apply:
    name: Terraform Apply
    needs: terraform-plan
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    strategy:
      matrix:
        environment: [dev]
      max-parallel: 1
    environment:
      name: ${{ matrix.environment }}
    permissions:
      contents: read
      id-token: write
    
    steps:
      # Apply steps...
```

## GitHub OIDC Setup

### Why OIDC?

**Traditional Approach** (Access Keys):
- ❌ Long-lived credentials
- ❌ Manual rotation required
- ❌ Higher security risk
- ❌ Harder to audit

**OIDC Approach**:
- ✅ Temporary credentials
- ✅ Automatic rotation
- ✅ No stored secrets
- ✅ Better audit trail
- ✅ Fine-grained permissions

### Architecture

```
┌─────────────────────────────────────────────────────────┐
│                   GitHub Actions                         │
│                                                          │
│  Workflow requests AWS access                            │
│         ↓                                                │
│  GitHub generates OIDC token with:                       │
│    - Repository info                                     │
│    - Branch/tag info                                     │
│    - Workflow info                                       │
└────────────────────┬────────────────────────────────────┘
                     │ OIDC Token
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    AWS STS                               │
│                                                          │
│  Validates OIDC token against:                           │
│    - OIDC provider thumbprint                            │
│    - IAM role trust policy                               │
│    - Repository/branch conditions                        │
│         ↓                                                │
│  Issues temporary credentials (1 hour)                   │
└────────────────────┬────────────────────────────────────┘
                     │ Temporary Credentials
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  AWS Resources                           │
│                                                          │
│  Workflow can now access AWS with temporary credentials  │
└─────────────────────────────────────────────────────────┘
```

### Step-by-Step Setup

#### 1. Create OIDC Provider (One-time)

```bash
aws iam create-open-id-connect-provider \
  --url https://token.actions.githubusercontent.com \
  --client-id-list sts.amazonaws.com \
  --thumbprint-list 6938fd4d98bab03faadb97b34396831e3780aea1
```

**Verify**:
```bash
aws iam list-open-id-connect-providers
```

#### 2. Create Trust Policy

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::123456789012:oidc-provider/token.actions.githubusercontent.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
        },
        "StringLike": {
          "token.actions.githubusercontent.com:sub": "repo:username/ops-solution:*"
        }
      }
    }
  ]
}
```

**Key Parts**:
- `Federated`: OIDC provider ARN
- `Action`: Allow assuming role via OIDC
- `Condition`: Restrict to specific repository

**More Restrictive Example** (main branch only):
```json
"StringLike": {
  "token.actions.githubusercontent.com:sub": "repo:username/ops-solution:ref:refs/heads/main"
}
```

#### 3. Create IAM Roles

**For Development**:
```bash
# Create role
aws iam create-role \
  --role-name github-actions-terraform-dev \
  --assume-role-policy-document file://trust-policy.json \
  --description "GitHub Actions role for dev deployments"

# Attach policies
aws iam attach-role-policy \
  --role-name github-actions-terraform-dev \
  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# Note: Use more restrictive policies in production
```

**For Production**:
```bash
# Create role
aws iam create-role \
  --role-name github-actions-terraform-prod \
  --assume-role-policy-document file://trust-policy.json \
  --description "GitHub Actions role for prod deployments"

# Attach policies
aws iam attach-role-policy \
  --role-name github-actions-terraform-prod \
  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
```

#### 4. Get Role ARNs

```bash
aws iam get-role \
  --role-name github-actions-terraform-dev \
  --query 'Role.Arn' \
  --output text
```

**Example Output**:
```
arn:aws:iam::123456789012:role/github-actions-terraform-dev
```

#### 5. Add to GitHub Secrets

Navigate to: `Settings` → `Secrets and variables` → `Actions`

Add secrets:
- `AWS_ROLE_ARN`: Dev role ARN
- `AWS_PROD_ROLE_ARN`: Prod role ARN
- `AWS_REGION`: `ap-southeast-1`
- `SECRET_MANAGER_NAME`: Name of secret in AWS
- `EKS_CLUSTER_NAME`: Name of EKS cluster

### Using OIDC in Workflows

```yaml
- name: Configure AWS Credentials
  uses: aws-actions/configure-aws-credentials@v4
  with:
    role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
    aws-region: ${{ secrets.AWS_REGION }}
    role-session-name: workflow-${{ github.run_id }}

- name: Verify Credentials
  run: |
    aws sts get-caller-identity
    # Output:
    # {
    #   "UserId": "AROA...:workflow-123456",
    #   "Account": "123456789012",
    #   "Arn": "arn:aws:sts::123456789012:assumed-role/github-actions-terraform-dev/workflow-123456"
    # }
```

## Secrets Configuration

### Required GitHub Secrets

| Secret Name | Description | Example | Used By |
|-------------|-------------|---------|---------|
| `AWS_ROLE_ARN` | IAM role for dev/staging | `arn:aws:iam::123...:role/github-...` | Both pipelines |
| `AWS_PROD_ROLE_ARN` | IAM role for production | `arn:aws:iam::123...:role/github-...` | Terraform pipeline |
| `AWS_REGION` | AWS region | `ap-southeast-1` | Both pipelines |
| `SECRET_MANAGER_NAME` | Secrets Manager secret name | `ops-solution-api-keys` | App pipeline |
| `EKS_CLUSTER_NAME` | EKS cluster name | `ops-solution-dev-eks` | App pipeline |

### AWS Secrets Manager

**Creating Secrets**:
```bash
# Create secret with JSON value
aws secretsmanager create-secret \
  --name ops-solution-api-keys \
  --description "API keys for application" \
  --secret-string '{"API_KEY":"super-secret-key-123"}' \
  --region ap-southeast-1

# Update secret
aws secretsmanager update-secret \
  --secret-id ops-solution-api-keys \
  --secret-string '{"API_KEY":"new-secret-key-456"}' \
  --region ap-southeast-1

# Enable rotation (optional)
aws secretsmanager rotate-secret \
  --secret-id ops-solution-api-keys \
  --rotation-lambda-arn arn:aws:lambda:...
```

**Retrieving in Pipeline**:
```bash
SECRET_VALUE=$(aws secretsmanager get-secret-value \
  --secret-id ops-solution-api-keys \
  --region ap-southeast-1 \
  --query SecretString \
  --output text)

API_KEY=$(echo "$SECRET_VALUE" | jq -r '.API_KEY')

# Mask in logs
echo "::add-mask::$API_KEY"
```

## Workflow Triggers

### Application Pipeline Triggers

```yaml
on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'src/**'
      - 'kube/**'
      - '.github/workflows/**'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'src/**'
      - 'kube/**'
```

| Event | Branch | Action |
|-------|--------|--------|
| Push | `main` | Build → Test → Deploy |
| Push | `develop` | Build → Test only |
| PR | Any → `main` | Build → Test only |
| PR | Any → `develop` | Build → Test only |

### Infrastructure Pipeline Triggers

```yaml
on:
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'iac/**'
  push:
    branches:
      - main
    paths:
      - 'iac/**'
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        options: [dev, prod]
```

| Event | Branch | Action |
|-------|--------|--------|
| PR | Any → `main` | Plan both envs + OPA |
| Push | `main` | Plan + Apply (dev only) |
| Manual | - | Plan + Apply (selected env) |

### Manual Workflow Dispatch

**Running manually**:
1. Go to Actions tab
2. Select workflow
3. Click "Run workflow"
4. Select environment
5. Click "Run workflow" button

**Via GitHub CLI**:
```bash
gh workflow run terraform.yml \
  -f environment=prod
```

## Best Practices

### 1. Workflow Design

✅ **Do**:
- Use job dependencies (`needs:`)
- Implement proper error handling
- Use concurrency controls
- Cache dependencies
- Use matrix builds for multi-env

❌ **Don't**:
- Run all jobs in parallel without dependencies
- Ignore failures with `continue-on-error`
- Skip testing stages
- Hardcode values

### 2. Security

✅ **Do**:
- Use OIDC instead of access keys
- Mask secrets in logs (`::add-mask::`)
- Use least privilege IAM roles
- Validate inputs
- Use signed commits

❌ **Don't**:
- Store secrets in code
- Echo secrets to logs
- Use overly permissive IAM policies
- Skip security scans

### 3. Performance

✅ **Do**:
- Use caching (Docker, npm, terraform)
- Use sparse checkouts when possible
- Parallelize independent jobs
- Set appropriate timeouts

❌ **Don't**:
- Checkout entire history unnecessarily
- Skip caching
- Run jobs sequentially when they could be parallel

### 4. Reliability

✅ **Do**:
- Implement atomic deployments
- Use rollback mechanisms
- Add verification steps
- Set appropriate timeouts
- Test in non-prod first

❌ **Don't**:
- Deploy without testing
- Skip health checks
- Ignore rollback failures

### 5. Cost Optimization

✅ **Do**:
- Use appropriate runner sizes
- Cancel redundant workflows
- Set workflow timeouts
- Clean up artifacts

❌ **Don't**:
- Leave long-running workflows
- Store unnecessary artifacts
- Use large runners unnecessarily

## Troubleshooting

### Common Issues

#### 1. OIDC Authentication Failed

**Error**:
```
Error: Not authorized to perform sts:AssumeRoleWithWebIdentity
```

**Solutions**:
```bash
# Check OIDC provider exists
aws iam list-open-id-connect-providers

# Check role trust policy
aws iam get-role --role-name github-actions-terraform-dev

# Verify trust policy includes:
# - Correct OIDC provider ARN
# - Correct repository path
# - sts:AssumeRoleWithWebIdentity action
```

#### 2. Docker Build Failed

**Error**:
```
ERROR: failed to solve: failed to fetch oauth token
```

**Solutions**:
```yaml
# Ensure login before build
- name: Log in to Container Registry
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}

# Check permissions
permissions:
  packages: write
```

#### 3. Health Check Timeout

**Error**:
```
✗ Health check failed after 15 attempts
```

**Solutions**:
```bash
# Increase timeout
max_attempts=30  # Increase from 15

# Check container logs
docker logs test-container

# Verify port mapping
docker run -d -p 3000:3000 ...  # Ensure correct port

# Check if app is listening
docker exec test-container netstat -tulpn | grep 3000
```

#### 4. Helm Deployment Failed

**Error**:
```
Error: UPGRADE FAILED: timed out waiting for the condition
```

**Solutions**:
```bash
# Check pod status
kubectl get pods

# Check pod events
kubectl describe pod <pod-name>

# Check logs
kubectl logs <pod-name>

# Common issues:
# - Image pull errors
# - Resource limits too low
# - Health check failures
# - Missing secrets
```

#### 5. OPA Validation Failed

**Error**:
```
FAIL: EKS cluster must have private endpoint access enabled
```

**Solutions**:
```hcl
# Fix Terraform configuration
module "eks" {
  # ...
  endpoint_private_access = true
}

# Re-run plan
terraform plan -var-file=dev.tfvars
```

#### 6. Secrets Not Found

**Error**:
```
ERROR: Failed to retrieve API_KEY from Secrets Manager
```

**Solutions**:
```bash
# Check secret exists
aws secretsmanager list-secrets

# Check secret value
aws secretsmanager get-secret-value --secret-id ops-solution-api-keys

# Check IAM permissions
aws iam simulate-principal-policy \
  --policy-source-arn arn:aws:iam::123...:role/github-actions... \
  --action-names secretsmanager:GetSecretValue \
  --resource-arns arn:aws:secretsmanager:ap-southeast-1:123...:secret:ops-solution-api-keys
```

### Debug Workflows

#### Enable Debug Logging

**Repository Settings**:
1. Go to Settings → Secrets and variables → Actions
2. Add secrets:
   - `ACTIONS_RUNNER_DEBUG`: `true`
   - `ACTIONS_STEP_DEBUG`: `true`

**Or in workflow**:
```yaml
env:
  ACTIONS_RUNNER_DEBUG: true
  ACTIONS_STEP_DEBUG: true
```

#### View Workflow Logs

```bash
# Install GitHub CLI
brew install gh

# List workflow runs
gh run list --workflow=ci-cd.yml

# View run details
gh run view <run-id>

# Download logs
gh run download <run-id>
```

#### Test Locally (act)

```bash
# Install act
brew install act

# Run workflow locally
act -j build-and-test

# With secrets
act -j build-and-test --secret-file .secrets
```

## Next Steps

After setting up CI/CD:

1. ✅ Monitor workflow executions
2. ✅ Set up notifications (Slack, email)
3. ✅ Create deployment dashboards
4. ✅ Document runbooks
5. ✅ Implement automated rollbacks
6. ✅ Add deployment gates

---

**Related Documentation**:
- [Infrastructure Guide](01.IAC.md)
- [Application Guide](02.Application.md)
- [OPA Policy Guide](04.OPA.md)
- [Main README](../README.md)

*Last updated: December 10, 2025*

