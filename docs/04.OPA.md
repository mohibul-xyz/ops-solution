# Open Policy Agent (OPA) - Policy as Code Guide

This document provides comprehensive documentation on using Open Policy Agent (OPA) for infrastructure policy validation in this project.

## Table of Contents

- [Overview](#overview)
- [Why Policy as Code?](#why-policy-as-code)
- [OPA Architecture](#opa-architecture)
- [Policy Files](#policy-files)
- [Terraform Best Practices Policies](#terraform-best-practices-policies)
- [Security Policies](#security-policies)
- [Cost Control Policies](#cost-control-policies)
- [Running OPA Validation](#running-opa-validation)
- [Writing Custom Policies](#writing-custom-policies)
- [Testing Policies](#testing-policies)
- [Troubleshooting](#troubleshooting)

## Overview

**Open Policy Agent (OPA)** is a policy engine that enables policy-as-code. In this project, OPA validates Terraform plans before they're applied, ensuring compliance with:

- **Best Practices**: Tagging, naming conventions, configuration standards
- **Security**: Encryption, access controls, network security
- **Cost Control**: Instance types, resource sizes, spending limits

### Benefits

✅ **Prevent Misconfigurations**: Catch issues before deployment  
✅ **Enforce Standards**: Consistent policies across all environments  
✅ **Cost Governance**: Prevent expensive resource creation  
✅ **Security Compliance**: Automated security checks  
✅ **Shift Left**: Find issues early in development  
✅ **Audit Trail**: Document policy decisions

### Technology Stack

| Component | Version | Purpose |
|-----------|---------|---------|
| OPA | 0.59.0+ | Policy engine |
| Rego | - | Policy language |
| Terraform | 1.6.0+ | Infrastructure tool |
| GitHub Actions | - | CI/CD platform |

## Why Policy as Code?

### Traditional Approach

```
Developer writes Terraform
    ↓
Manual code review
    ↓
Apply to AWS
    ↓
❌ Discover security issue in production
    ↓
Emergency fix
    ↓
Costly incident
```

**Problems**:
- ❌ Manual reviews are slow and error-prone
- ❌ Issues discovered too late
- ❌ Inconsistent enforcement
- ❌ No audit trail
- ❌ Tribal knowledge

### Policy-as-Code Approach

```
Developer writes Terraform
    ↓
Automated policy validation (OPA)
    ↓
✅ All policies pass
    ↓
Automated code review
    ↓
Apply to AWS
    ↓
✓ Compliant infrastructure
```

**Benefits**:
- ✅ Fast, consistent validation
- ✅ Issues caught before deployment
- ✅ Automated enforcement
- ✅ Documented policies
- ✅ Auditable decisions

## OPA Architecture

### How OPA Works

```
┌─────────────────────────────────────────────────────────┐
│                  Terraform Plan                          │
│                                                          │
│  terraform plan -out=tfplan.binary                       │
│  terraform show -json tfplan.binary > tfplan.json        │
└────────────────────┬────────────────────────────────────┘
                     │ JSON Plan
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    OPA Engine                            │
│                                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │            Load Policy Files                      │   │
│  │  • terraform.rego (best practices)               │   │
│  │  • security.rego (security rules)                │   │
│  │  • cost_control.rego (cost rules)                │   │
│  └──────────────────┬───────────────────────────────┘   │
│                     │                                    │
│  ┌──────────────────▼───────────────────────────────┐   │
│  │         Evaluate Plan Against Policies           │   │
│  │  • Check each resource                           │   │
│  │  • Apply deny rules                              │   │
│  │  • Apply warn rules                              │   │
│  └──────────────────┬───────────────────────────────┘   │
│                     │                                    │
│  ┌──────────────────▼───────────────────────────────┐   │
│  │            Generate Results                       │   │
│  │  • Violations (deny)                             │   │
│  │  • Warnings (warn)                               │   │
│  │  • Pass/Fail decision                            │   │
│  └──────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                      Output                              │
│                                                          │
│  ✓ All policies passed                                   │
│  OR                                                      │
│  ✗ Policy violations found:                              │
│    - Resource 'xyz' missing required tag                │
│    - EKS cluster must have private endpoint access      │
│    - Dev cannot use instance type t3.large              │
└─────────────────────────────────────────────────────────┘
```

### Policy File Structure

```
iac/policies/
├── terraform.rego          # Best practices
├── security.rego          # Security policies
├── cost_control.rego      # Cost governance
├── README.md              # Policy documentation
└── tests/                 # Policy tests (optional)
    ├── terraform_test.rego
    ├── security_test.rego
    └── cost_control_test.rego
```

## Policy Files

### Location

```
iac/
└── policies/
    ├── terraform.rego      # 131 lines
    ├── security.rego       # 128 lines
    ├── cost_control.rego   # 85 lines
    └── README.md
```

### Rego Language Basics

Rego is a declarative language for defining policies:

```rego
package my_policy

import future.keywords.if
import future.keywords.in

# Rule that denies something
deny[msg] {
    # Condition 1
    condition_is_true
    
    # Condition 2
    other_condition_is_true
    
    # Set error message
    msg := "This is not allowed"
}

# Rule that warns about something
warn[msg] {
    # Conditions
    something_is_suboptimal
    
    msg := "This is not recommended"
}
```

**Key Concepts**:
- **Packages**: Organize policies
- **Rules**: Define conditions (`deny`, `warn`, `allow`)
- **Conditions**: All must be true for rule to match
- **Arrays**: Use `[_]` to iterate
- **Messages**: Formatted with `sprintf()`

## Terraform Best Practices Policies

**File**: `iac/policies/terraform.rego`

### Policy 1: Required Tags

**Purpose**: Ensure all resources have Environment and ManagedBy tags for tracking and cost allocation.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.change.actions[_] == "create"
    not resource.change.after.tags.Environment
    msg := sprintf("Resource '%s' is missing required tag: Environment", [resource.address])
}

deny[msg] {
    resource := input.resource_changes[_]
    resource.change.actions[_] == "create"
    not resource.change.after.tags.ManagedBy
    msg := sprintf("Resource '%s' is missing required tag: ManagedBy", [resource.address])
}
```

**What it checks**:
- All created resources must have `Environment` tag
- All created resources must have `ManagedBy` tag

**Example violation**:
```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
  # Missing tags!
}
```

**Fix**:
```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
  
  tags = {
    Environment = "dev"
    ManagedBy   = "Terraform"
  }
}
```

### Policy 2: VPC DNS Configuration

**Purpose**: Ensure VPCs have DNS support and hostnames enabled (required for EKS).

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_vpc"
    resource.change.after.enable_dns_support == false
    msg := sprintf("VPC '%s' must have DNS support enabled", [resource.address])
}

deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_vpc"
    resource.change.after.enable_dns_hostnames == false
    msg := sprintf("VPC '%s' must have DNS hostnames enabled", [resource.address])
}
```

**What it checks**:
- VPC must have `enable_dns_support = true`
- VPC must have `enable_dns_hostnames = true`

**Why it matters**: EKS requires DNS support for service discovery.

### Policy 3: EKS Private Endpoint Access

**Purpose**: Ensure EKS clusters have private endpoint access for security.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_eks_cluster"
    resource.change.after.vpc_config[_].endpoint_private_access == false
    msg := sprintf("EKS cluster '%s' must have private endpoint access enabled", [resource.address])
}
```

**What it checks**:
- EKS clusters must have private endpoint access enabled

**Why it matters**: Allows nodes to communicate with control plane privately.

### Policy 4: EKS Node Encryption

**Purpose**: Ensure EKS node volumes are encrypted.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_launch_template"
    contains(resource.address, "eks")
    volume := resource.change.after.block_device_mappings[_]
    not volume.ebs.encrypted
    msg := sprintf("EKS node template '%s' must have encrypted volumes", [resource.address])
}
```

**What it checks**:
- Launch templates for EKS nodes must have encrypted EBS volumes

**Why it matters**: Encryption at rest is a security best practice.

### Policy 5: Security Group Rules

**Purpose**: Prevent unrestricted SSH access.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_security_group"
    rule := resource.change.after.ingress[_]
    rule.from_port <= 22
    rule.to_port >= 22
    cidr := rule.cidr_blocks[_]
    cidr == "0.0.0.0/0"
    msg := sprintf("Security group '%s' allows SSH from 0.0.0.0/0", [resource.address])
}
```

**What it checks**:
- Security groups cannot allow SSH (port 22) from 0.0.0.0/0

**Why it matters**: Unrestricted SSH access is a major security risk.

### Policy 6: ALB Deletion Protection

**Purpose**: Ensure production ALBs have deletion protection.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lb"
    contains(resource.address, "prod")
    resource.change.after.enable_deletion_protection == false
    msg := sprintf("Production ALB '%s' must have deletion protection enabled", [resource.address])
}
```

**What it checks**:
- Production ALBs must have deletion protection enabled

**Why it matters**: Prevents accidental deletion of critical infrastructure.

### Policy 7: CloudWatch Log Retention

**Purpose**: Ensure logs are retained for auditing.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_cloudwatch_log_group"
    not resource.change.after.retention_in_days
    msg := sprintf("CloudWatch log group '%s' must have retention period set", [resource.address])
}

deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_cloudwatch_log_group"
    resource.change.after.retention_in_days < 7
    msg := sprintf("CloudWatch log group '%s' retention must be at least 7 days", [resource.address])
}
```

**What it checks**:
- Log groups must have retention period set
- Retention must be at least 7 days

**Why it matters**: Logs needed for debugging and compliance.

## Security Policies

**File**: `iac/policies/security.rego`

### Policy 1: S3 Bucket Encryption

**Purpose**: Ensure all S3 buckets are encrypted.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_s3_bucket"
    not has_encryption(resource.address)
    msg := sprintf("S3 bucket '%s' must have encryption enabled", [resource.address])
}

has_encryption(bucket_address) {
    resource := input.resource_changes[_]
    resource.type == "aws_s3_bucket_server_side_encryption_configuration"
    contains(resource.address, bucket_address)
}
```

**What it checks**:
- S3 buckets must have encryption configuration

**Fix**:
```hcl
resource "aws_s3_bucket_server_side_encryption_configuration" "bucket" {
  bucket = aws_s3_bucket.bucket.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}
```

### Policy 2: EBS Volume Encryption

**Purpose**: Ensure EBS volumes are encrypted.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_ebs_volume"
    resource.change.after.encrypted == false
    msg := sprintf("EBS volume '%s' must be encrypted", [resource.address])
}
```

**What it checks**:
- All EBS volumes must have `encrypted = true`

### Policy 3: RDS Encryption

**Purpose**: Ensure RDS instances use encrypted storage.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_db_instance"
    resource.change.after.storage_encrypted == false
    msg := sprintf("RDS instance '%s' must have storage encryption enabled", [resource.address])
}
```

### Policy 4: Security Group Port Restrictions

**Purpose**: Prevent unrestricted access to sensitive ports.

```rego
sensitive_ports := [22, 3389, 3306, 5432, 1433, 6379, 27017]

deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_security_group"
    rule := resource.change.after.ingress[_]
    port := rule.from_port
    port in sensitive_ports
    cidr := rule.cidr_blocks[_]
    cidr == "0.0.0.0/0"
    msg := sprintf("Security group '%s' allows unrestricted access to sensitive port %d from 0.0.0.0/0", 
        [resource.address, port])
}
```

**Sensitive ports**:
- 22: SSH
- 3389: RDP
- 3306: MySQL
- 5432: PostgreSQL
- 1433: SQL Server
- 6379: Redis
- 27017: MongoDB

### Policy 5: IMDSv2 Enforcement

**Purpose**: Require IMDSv2 on EC2 instances (prevents SSRF attacks).

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_launch_template"
    metadata := resource.change.after.metadata_options[_]
    metadata.http_tokens != "required"
    msg := sprintf("Launch template '%s' must require IMDSv2 (http_tokens = required)", [resource.address])
}
```

**What it checks**:
- Launch templates must have `http_tokens = "required"`

**Why it matters**: IMDSv2 protects against SSRF attacks on metadata service.

### Policy 6: Public IP Assignment

**Purpose**: Warn about public IP assignments in production.

```rego
warn[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_instance"
    contains(resource.address, "prod")
    resource.change.after.associate_public_ip_address == true
    msg := sprintf("Production instance '%s' is assigned a public IP address. Consider using private subnets with NAT gateway.", 
        [resource.address])
}
```

### Policy 7: VPC Flow Logs Recommendation

**Purpose**: Recommend enabling VPC flow logs.

```rego
warn[msg] {
    vpc := input.resource_changes[_]
    vpc.type == "aws_vpc"
    not has_flow_logs(vpc.address)
    msg := sprintf("VPC '%s' does not have flow logs enabled. Consider enabling for network monitoring.", 
        [vpc.address])
}
```

## Cost Control Policies

**File**: `iac/policies/cost_control.rego`

### Policy 1: Instance Type Restrictions

**Purpose**: Limit instance types by environment to control costs.

```rego
allowed_dev_instances := ["t3.micro", "t3.small", "t3.medium", "t2.micro", "t2.small", "t2.medium"]
allowed_prod_instances := ["m6a.large", "m6a.xlarge"]

deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_eks_node_group"
    contains(resource.address, "dev")
    instance_type := resource.change.after.instance_types[_]
    not instance_type in allowed_dev_instances
    msg := sprintf("Dev environment '%s' cannot use expensive instance type: %s. Allowed: %v", 
        [resource.address, instance_type, allowed_dev_instances])
}

deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_eks_node_group"
    contains(resource.address, "prod")
    instance_type := resource.change.after.instance_types[_]
    not instance_type in allowed_prod_instances
    msg := sprintf("Prod environment '%s' instance type %s not in allowed list: %v", 
        [resource.address, instance_type, allowed_prod_instances])
}
```

**What it enforces**:
- Dev: Only t2/t3 small-medium instances
- Prod: Only m6a large-xlarge instances

### Policy 2: Disk Size Limits

**Purpose**: Limit disk sizes in dev to control costs.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_launch_template"
    contains(resource.address, "dev")
    volume := resource.change.after.block_device_mappings[_]
    volume.ebs.volume_size > 50
    msg := sprintf("Dev environment '%s' disk size exceeds 50GB limit: %dGB", 
        [resource.address, volume.ebs.volume_size])
}
```

**What it enforces**:
- Dev environments limited to 50GB disk size

### Policy 3: Node Count Limits

**Purpose**: Warn about excessive node counts.

```rego
warn[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_eks_node_group"
    contains(resource.address, "dev")
    max_size := resource.change.after.scaling_config[_].max_size
    max_size > 5
    msg := sprintf("Dev node group '%s' has high max_size: %d. Consider if this is necessary.", 
        [resource.address, max_size])
}
```

### Policy 4: Cost Center Tagging

**Purpose**: Require cost center tags for cost allocation.

```rego
deny[msg] {
    resource := input.resource_changes[_]
    resource.change.actions[_] == "create"
    has_cost(resource.type)
    not resource.change.after.tags.CostCenter
    msg := sprintf("Resource '%s' is missing required tag: CostCenter (for cost allocation)", [resource.address])
}

has_cost(resource_type) {
    cost_resources := ["aws_instance", "aws_eks_node_group", "aws_rds_instance", "aws_elasticache_cluster"]
    resource_type == cost_resources[_]
}
```

### Policy 5: Expensive Resource Warnings

**Purpose**: Warn about potentially expensive resources.

```rego
warn[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_nat_gateway"
    msg := sprintf("NAT Gateway '%s' costs ~$32/month. Consider using single NAT for dev environments.", 
        [resource.address])
}

warn[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_eks_cluster"
    msg := sprintf("EKS cluster '%s' control plane costs $0.10/hour (~$73/month).", 
        [resource.address])
}
```

## Running OPA Validation

### Prerequisites

```bash
# Install OPA
# macOS
brew install opa

# Linux
curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64
chmod +x opa
sudo mv opa /usr/local/bin/

# Verify
opa version
```

### Manual Validation

```bash
cd iac/environment/dev

# 1. Initialize Terraform
terraform init -backend-config=../../backend-dev.hcl

# 2. Create plan
terraform plan -var-file=dev.tfvars -out=tfplan.binary

# 3. Convert to JSON
terraform show -json tfplan.binary > tfplan.json

# 4. Run validation script
cd ../..
./scripts/validate-with-opa.sh environment/dev/tfplan.json
```

### Validation Script

**Location**: `iac/scripts/validate-with-opa.sh`

```bash
#!/bin/bash

PLAN_FILE=$1

if [ -z "$PLAN_FILE" ]; then
    echo "Usage: $0 <terraform-plan.json>"
    exit 1
fi

echo "Running OPA Policy Validation..."
echo "================================="

FAILED=0

# Check Terraform best practices
echo "Checking Terraform policies..."
opa eval --data policies/terraform.rego \
         --input "$PLAN_FILE" \
         --format pretty \
         "data.terraform.deny"

if [ $? -ne 0 ]; then
    FAILED=1
fi

# Check security policies
echo "Checking security policies..."
opa eval --data policies/security.rego \
         --input "$PLAN_FILE" \
         --format pretty \
         "data.terraform.security.deny"

if [ $? -ne 0 ]; then
    FAILED=1
fi

# Check cost control policies
echo "Checking cost control policies..."
opa eval --data policies/cost_control.rego \
         --input "$PLAN_FILE" \
         --format pretty \
         "data.terraform.cost.deny"

if [ $? -ne 0 ]; then
    FAILED=1
fi

echo ""
echo "================================="

if [ $FAILED -eq 1 ]; then
    echo "✗ Policy violations found!"
    exit 1
else
    echo "✓ All OPA validations passed!"
fi
```

### CI/CD Integration

Automatically runs in GitHub Actions:

```yaml
- name: Run OPA Policy Validation
  run: |
    chmod +x scripts/validate-with-opa.sh
    scripts/validate-with-opa.sh tfplan.json
```

**Pipeline fails if**:
- Any `deny` rule matches
- OPA evaluation errors

**Pipeline continues if**:
- Only `warn` rules match (warnings logged)

### Example Output

**Success**:
```
Running OPA Policy Validation...
=================================
Checking Terraform policies...
[]
✓ Terraform policies: PASSED

Checking security policies...
[]
✓ Security policies: PASSED

Checking cost control policies...
["WARN: NAT Gateway costs ~$32/month"]
✓ Cost control policies: PASSED

=================================
✓ All OPA validations passed!
```

**Failure**:
```
Running OPA Policy Validation...
=================================
Checking Terraform policies...
[
  "Resource 'module.vpc.aws_vpc.main' is missing required tag: ManagedBy",
  "EKS cluster 'module.eks.aws_eks_cluster.main' must have private endpoint access enabled"
]
✗ Terraform policy violations found

Checking security policies...
[
  "Security group 'module.eks.aws_security_group.nodes' allows SSH from 0.0.0.0/0"
]
✗ Security policy violations found

=================================
✗ Policy violations found!
```

## Writing Custom Policies

### Basic Template

```rego
# Package declaration
package custom_policies

# Import future keywords
import future.keywords.if
import future.keywords.in

# Deny rule
deny[msg] {
    # Select resource
    resource := input.resource_changes[_]
    
    # Check resource type
    resource.type == "aws_some_resource"
    
    # Check condition
    resource.change.after.some_attribute == false
    
    # Format message
    msg := sprintf("Resource '%s' violates policy", [resource.address])
}

# Warn rule
warn[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_some_resource"
    resource.change.after.some_optional_setting == false
    msg := sprintf("Resource '%s': Consider enabling optional setting", [resource.address])
}

# Helper function
has_feature(resource_address) {
    resource := input.resource_changes[_]
    resource.type == "aws_feature_config"
    contains(resource.address, resource_address)
}
```

### Example: Custom VPC CIDR Policy

```rego
package custom.networking

import future.keywords.if

# Deny overlapping CIDR blocks
deny[msg] {
    vpc1 := input.resource_changes[_]
    vpc1.type == "aws_vpc"
    
    vpc2 := input.resource_changes[_]
    vpc2.type == "aws_vpc"
    
    vpc1.address != vpc2.address
    cidrs_overlap(vpc1.change.after.cidr_block, vpc2.change.after.cidr_block)
    
    msg := sprintf("VPC CIDRs overlap: %s and %s", [vpc1.address, vpc2.address])
}

# Require specific CIDR ranges per environment
deny[msg] {
    vpc := input.resource_changes[_]
    vpc.type == "aws_vpc"
    contains(vpc.address, "dev")
    not startswith(vpc.change.after.cidr_block, "10.0.")
    msg := sprintf("Dev VPC '%s' must use 10.0.x.x CIDR range", [vpc.address])
}

deny[msg] {
    vpc := input.resource_changes[_]
    vpc.type == "aws_vpc"
    contains(vpc.address, "prod")
    not startswith(vpc.change.after.cidr_block, "10.1.")
    msg := sprintf("Prod VPC '%s' must use 10.1.x.x CIDR range", [vpc.address])
}
```

### Example: Custom Naming Convention

```rego
package custom.naming

import future.keywords.if

# Enforce naming pattern: {project}-{env}-{resource}
deny[msg] {
    resource := input.resource_changes[_]
    has_name(resource)
    name := get_name(resource)
    not matches_pattern(name)
    msg := sprintf("Resource '%s' name '%s' doesn't match pattern: {project}-{env}-{resource}", 
        [resource.address, name])
}

has_name(resource) {
    resource.change.after.name
}

has_name(resource) {
    resource.change.after.tags.Name
}

get_name(resource) = name {
    name := resource.change.after.name
}

get_name(resource) = name {
    not resource.change.after.name
    name := resource.change.after.tags.Name
}

matches_pattern(name) {
    parts := split(name, "-")
    count(parts) >= 3
}
```

## Testing Policies

### Unit Testing with OPA

Create test files alongside policy files:

```rego
# terraform_test.rego
package terraform_test

import data.terraform

# Test: Resource without Environment tag should fail
test_missing_environment_tag {
    input := {
        "resource_changes": [{
            "address": "aws_vpc.test",
            "type": "aws_vpc",
            "change": {
                "actions": ["create"],
                "after": {
                    "tags": {
                        "ManagedBy": "Terraform"
                    }
                }
            }
        }]
    }
    
    count(terraform.deny) > 0
}

# Test: Resource with all tags should pass
test_all_required_tags {
    input := {
        "resource_changes": [{
            "address": "aws_vpc.test",
            "type": "aws_vpc",
            "change": {
                "actions": ["create"],
                "after": {
                    "tags": {
                        "Environment": "dev",
                        "ManagedBy": "Terraform"
                    }
                }
            }
        }]
    }
    
    count(terraform.deny) == 0
}
```

**Run tests**:
```bash
# Run all tests
opa test policies/ -v

# Run specific test file
opa test policies/terraform_test.rego -v

# Expected output:
# terraform_test.rego:
#   test_missing_environment_tag: PASS (0.5ms)
#   test_all_required_tags: PASS (0.3ms)
# PASS: 2/2
```

### Integration Testing

```bash
# Create test Terraform plan
cd tests/terraform
terraform init
terraform plan -out=test.tfplan
terraform show -json test.tfplan > test.json

# Run OPA validation
opa eval --data ../../policies/ \
         --input test.json \
         --format pretty \
         "data.terraform.deny"
```

## Troubleshooting

### Common Issues

#### 1. Policy Not Triggering

**Problem**: Policy rule doesn't trigger when it should.

**Debug**:
```bash
# Check input structure
opa eval --data policies/terraform.rego \
         --input tfplan.json \
         --format pretty \
         "input.resource_changes"

# Print specific resource
opa eval --data policies/terraform.rego \
         --input tfplan.json \
         --format pretty \
         "input.resource_changes[0]"

# Check rule evaluation
opa eval --data policies/terraform.rego \
         --input tfplan.json \
         --format pretty \
         --explain full \
         "data.terraform.deny"
```

#### 2. False Positives

**Problem**: Policy triggers when it shouldn't.

**Solution**: Add conditions to narrow scope:
```rego
# Before (too broad)
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_security_group"
    msg := "All security groups denied"
}

# After (more specific)
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_security_group"
    resource.change.actions[_] == "create"  # Only on create
    contains(resource.address, "prod")  # Only prod
    # Additional specific conditions...
}
```

#### 3. Policy Syntax Errors

**Problem**: Rego syntax errors.

**Check syntax**:
```bash
opa fmt policies/terraform.rego
opa check policies/terraform.rego
```

**Common errors**:
- Missing brackets
- Wrong variable names
- Incorrect indentation
- Missing imports

#### 4. Performance Issues

**Problem**: Policy evaluation is slow.

**Solutions**:
```rego
# Use indexing for lookups
# Bad (O(n²))
has_encryption(bucket) {
    encryption := input.resource_changes[_]
    encryption.type == "aws_s3_bucket_server_side_encryption_configuration"
    contains(encryption.address, bucket)
}

# Good (O(n))
encryption_configs[address] = config {
    config := input.resource_changes[_]
    config.type == "aws_s3_bucket_server_side_encryption_configuration"
    address := config.address
}

has_encryption(bucket) {
    encryption_configs[bucket]
}
```

### Debug Commands

```bash
# Format policy files
opa fmt -w policies/

# Check syntax
opa check policies/

# Run tests
opa test policies/ -v

# Evaluate specific rule
opa eval --data policies/terraform.rego \
         --input tfplan.json \
         "data.terraform.deny"

# Interactive REPL
opa run policies/terraform.rego tfplan.json
# Then type queries:
> data.terraform.deny
> input.resource_changes[0]
```

## Best Practices

### 1. Policy Organization

✅ **Do**:
- Group related policies in packages
- Use descriptive rule names
- Add comments explaining why
- Keep policies focused

❌ **Don't**:
- Mix concerns in one file
- Create overly complex rules
- Skip documentation

### 2. Error Messages

✅ **Do**:
- Provide actionable error messages
- Include resource address
- Suggest fixes
- Use consistent formatting

❌ **Don't**:
- Use vague error messages
- Skip context
- Use technical jargon

### 3. Testing

✅ **Do**:
- Write unit tests for policies
- Test both positive and negative cases
- Test edge cases
- Run tests in CI/CD

❌ **Don't**:
- Deploy untested policies
- Skip edge cases
- Assume policies work

### 4. Performance

✅ **Do**:
- Use efficient queries
- Index data when possible
- Limit iterations
- Profile slow policies

❌ **Don't**:
- Use nested loops unnecessarily
- Duplicate checks
- Process all resources when targeting specific ones

## Next Steps

After understanding OPA:

1. ✅ Review existing policies
2. ✅ Customize for your needs
3. ✅ Add custom policies
4. ✅ Write tests
5. ✅ Monitor policy violations
6. ✅ Iterate and improve

---

**Related Documentation**:
- [Infrastructure Guide](01.IAC.md)
- [Application Guide](02.Application.md)
- [CI/CD Workflow Guide](03.Workflow.md)
- [Main README](../README.md)

**External Resources**:
- [OPA Documentation](https://www.openpolicyagent.org/docs/latest/)
- [Rego Language Guide](https://www.openpolicyagent.org/docs/latest/policy-language/)
- [OPA Playground](https://play.openpolicyagent.org/)

*Last updated: December 10, 2025*

